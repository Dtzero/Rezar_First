#JS作用域#
</b>
##1.什么是作用域##

任何一个编程语言都可以存储变量，并对变量的值进行修改，但是如何引入变量是一个问题，变量存储在哪里  如何找到变量。

为了更好的让我们找到这些变量的存储位置，和如何让程序找到变量，我们创建了一系列的规则，这些规则则被我们称为作用域；

###1.1 编译原理###

每一条代码执行前都会经历三个步骤 

	1. 分词/词法分析
	2. 解析/语法分析
	3. 代码生成


**分词/词法分析**

这个过程将会把字符组成的字符串代码分解为有意义的代码块，这些代码块我们称之为词法单元，例如：

	var a = 2；

这段代码将会被分解为 var、a、=、2、;。空格能否被当成词法单元取决于空格在代码中是否有意义；

**解析/语法单元**

这个过程则是将词法单元的集合变为一个由元素逐级嵌套组成的符合语法规则的树（我们称这个树为抽象语法树，简称为AST），例如

		  var
		 /
		x
	   /
	  =
	 /
	2

**代码生成**

这个过程则是将我们所解析的树转化为可执行的代码，抛开各种语言的不同和平台不同，简单的来说就是将var a = 2的抽象语法树变为机器可读的指令，让机器创建一个a变量，并赋值为2；

**重点**

与其它的语言不同，js的代码并没有耗费大量的时间进行优化，因为js的编译并不是提前执行的，大部分的情况下代码的编译时间处于代码执行的前非常小的时间段内（几微秒甚至更短的时间内），所以任何js代码都会在执行前进行编译，而且通常都会在编译之后立刻执行

###1.2 理解作用域###

每段代码的执行都需要不同的东西相互配合，大概由以下三种

1. 引擎
2. 编译器
3. 作用域

###1.2 理解作用域###

每段代码的执行都需要不同的东西相互配合，大概由以下三种

1. 引擎
2. 编译器
3. 作用域


**引擎**  

负责整个javascript的程序的编译以及执行

**编译器**

负责语法分析以及代码生成

**作用域**

负责收集并维护由所有声明的标识符（变量） 组成的一系列查询， 并实施一套非常严格的规则， 确定当前执行的代码对这些标识符的访问权限。

简而言之就是负责变量的存取以及读写工作；

####1.3 javascript的解析流程###

var x = 2；  

当这条声明语句执行时，我们可能会认为是一条语句，声明x变量赋值为2；

但是javascript的解析流程却不是这样，当javascript引擎读取到这段声明时，会被当成2条语句执行，一个在编译时执行  一个由引擎在运行时处理。

首先引擎读取到这段声明时  首先会执行var x；  首先询问编译器内是否有相同的变量，如果有则会忽略该声明继续编译；如果没有该变量，则新建一个变量存储在当前的作用域中，并命名为x；

然后编译器会准备引擎运行时所需要的代码。这些代码用来处理x=2这个赋值操作，首先引擎运行时会询问当前作用域是否有一个x的变量值，如果有，则调用该变量，如果没有则继续向下查找，直到找到，如果最终找不到x变量，则会报错。

**总结：** 

变量的赋值操作会执行两个动作， 首先编译器会在当前作用域中声明一个变量（如
果之前没有声明过）， 然后在运行时引擎会在作用域中查找该变量， 如果能够找到就会对
它赋值

###1.4 查询操作###

编译器会生成引擎所需要的代码，引擎在运行这些代码时会去作用域查询变量，但是查询的方式有所不同，不同的查询可能会导致不同的运行结果；

查询有两种方式，

1. LHS查询
2. RHS查询

我们可以明确看出  L和R代表的是左右，或者我们可以说   当变量出现在赋值左侧时调用LHS查询，出现在右侧时调用RHS查询；

##2 词法作用域##

词法作用域一共有两种模式，一种是普遍的，被大多数编程语言所采用的，叫做词法作用域；另一种是动态作用域，JS中并不采用，暂时不做了解；

###2.1 词法阶段###

一般我们编译器编译代码时的第一个工作叫做词法化（单词化）；词法化会对代码逐一进行检查。

换句话来说，词法作用域就是在你写代码时规定的块以及变量的作用域，因此当词法分析器处理会保持作用域不变（JS中有欺骗词法作用域的写法，下边单独讨论）；

	function foo(a) {
		var b = a * 2;`
		function bar(c) {
		console.log( a, b, c );
		} 
		bar( b * 3 );
	} 

	foo( 2 ); // 2, 4, 12

这个例子中有三个嵌套的作用域

1. 首先是全局作用域里边有一个foo标识符；
2. 然后是foo作用域，里边包含着a,b,bar三个标识符；
3. 最后是标识符bar所创建的作用域；

**查找**、

作用域的结构和相对的位置给引擎提供了位置信息，引擎利用这些位置找到相对的标识符，进而找到对应的作用域；

全局变量会自动生成为全局对象（比如window）的属性，因此可以利用window.a来直接调用；

##2.2 eval()##

JS中给我们提供了一个函数叫做eval()，这是一种欺骗作用域的写法，eval()函数中可以跟字符串作为参数，并且将其中内容视为一开始书写时就在的位置，也就是一种动态插入代码的方式  比如以下代码

	function foo(str, a) {
		eval( str ); // 欺骗！
		console.log( a, b );
	}
	var b = 2;
	foo( "var b = 3;", 1 ); // 1, 3

eval()中调用的var b = 3会被当作本来就出现在那里的写法；所以会在函数内部创造一个标识符为b的作用域，并且屏蔽掉外部的标识符b；

##2.3 with语句##

JS中还有一个比较难于理解的语句叫做with()，某种意义上，with语句也会造成欺骗词法作用域的效果；

我们使用with是为了避免重复书写相同的东西，但是with有这不可忽视的副作用，例如

	function foo(obj) {
		with (obj) {
			a = 2;
		}
	}
	var o2 = {
		b: 3
	};
	
	foo( o2 );
	console.log( o2.a ); // undefined
	console.log( a ); // 2

这里有个特殊的效果就是，a被定义成为了全局变量，这是因为with机制会将当前的对象放入一个with语句所创建的一个新的作用域，并且分配一个新的标识符，这种机制很难理解，但是就是这么操作的，这意味着原先我们定义时所分配的作用域被完全抛弃了，所以with语句会大大增加代码的运行时间，如果你在你的代码中使用了过多的with，这会将使你的代码加载速度变得非常慢；

继续看我们的代码  当调用foo并传参o2时  因为在当前的o2的作用域内找不到a标识符，这时候执行a=2就会在全局中创建一个a变量，并赋值为2；

某种意义上说，with会脱离我们的正常作用域，所以尽量在代码中不要使用with；


##性能##

with和eval()理论上可以为我们增加了更多的代码的可扩展性，但是在引擎看来这是并不可取的方法，因为我们的引擎会在编译时对代码进行多种优化，而使用eval()和with则让这个优化变得十分困难，因为引擎也不确定eval()内会接受到什么样的字符串，也无法确定with的对象，所以引擎会对这两部分采取不优化的方案，这使得你的代码执行时间将会大大加长，所以尽量避免在书写代码时使用欺骗作用域的做法；

##3 函数作用域和块作用域##

我们已经知道作用域是一系列的容器，内部包含有标识符和变量等一系列东西，这些容器相互嵌套并成树状结构分布，那么到底是什么创建这些容器，除去函数，其他的结构能否生成作用域吗？

##3.1 函数中的作用域##

函数会创建一个自己的作用域，这个作用域的位置是属于函数本身，外部无法从函数内部的作用域中调取变量和参数等。相反，函数内部可以调用外部的作用域，并且寻找到外部作用域内定义的标识符；

##3.2 代码的隐藏##

我们传统的对于函数的认知是，首先我们要先声明一个函数，然后在其函数内部再书写代码，在作用域范畴，我们认知是声明了一个作用域，并在这个作用域内添加代码，反过来看，我们也是相当于在代码外部包裹了一层气泡（也就是作用域），使得外部不能访问到内部的代码，这种方式叫做代码的隐藏；

这个隐藏方式是基于最小特权原则来实现，最小特权原则就是在软件设计过程中应该最小程度暴露必要的内容，而将其他都隐藏起来，比如模块以及API设计;

###规避冲突###

隐藏的另一个好处就是可以避免同名标识符之间的冲突，若在都在同一作用域下写代码，则有可能会有相同命名但有不同的作用的标识符，后边会覆盖掉前边的标识符，使用代码隐藏则会使得作用域内部和外部分隔开，可以有效避免标识符重名的情况

###全局作用域冲突###

标识符冲突的另一个方面就是当你的代码使用多个第三方库的时候，这些库如果没有合理的将内部的代码隐藏起来，而是暴露在了全局作用域中，这时候就很可能引发冲突（除非你熟知这些库的各种标识符，但这样可以规避一些冲突，但是最佳的解决办法还是将内部的代码隐藏起来，只暴露必要的函数名标识符就好）；

**合理的库规则**

我们写第三方插件或者库的时候也应当遵循最小特权原则，即尽量只在全局作用域中声明一个足够特别的标识符，用来标识我们写的对象，而将大部分代码通过函数作用隐藏起来,例如：

	var MyReallyCoolLibrary = {
		awesome: "stuff",
		doSomething: function() {
		// ...
		},
		doAnotherThing: function() {
		// ...
		}
	};

##3.3 函数作用域##

我们已经可以得知，在任意代码外部包裹一个函数可以使得内部代码隐藏，例如：

	function foo（）{
		var a = 3；
		console.log(a);
	)
	foo();

以上代码定义了一个名为foo的函数，并在外部对其进行了调用，这种方式隐藏内部代码是有问题的；首先我们必须先创建一个函数，并为这个函数命名，这样就会使得全局作用域中出现了一个名为foo的标识符；

其次，我们必须通过调用这个标识符才能使得代码执行，这为我们的代码正确执行带了一些麻烦；如果函数不需要函数名就可以直接执行，这样会更加的理想；

###匿名和具名###

对于函数表达式，其有匿名和具名两种，我们最熟悉的一种匿名函数表达式就是定时器函数

	setTimeout( function() {
		console.log("I waited 1 second!");
	}, 1000 );

由于函数本身没有标识符命名，这种函数被称为匿名函数，函数表达式是可以匿名的，但是函数声明是不可以匿名的，在JS中匿名的函数声明时违法的；

匿名函数在书写的时候非常简便，例如var x = function（）{}；但是这种写法也有几个缺点需要考虑；

1. 匿名函数在栈追踪（一种在内存中读取数据的机制，基于栈结构实现）时，因为没有具体的标识符会使调试变得有些困难；
2. 由于函数本身没有标识符，当在递归中调用自己的时候只能用过时的argument-callee指令，所以建议如果函数需要递归使用，最好给予标识符；
3. 匿名函数的可读性比较差，因为一个明确的标识符能有助于开发者明确了解函数的代码意义；

###立即执行函数表达式###

我们还可以使用（）来包裹匿名函数使得函数立即执行；当声明函数被小括号包裹时候就变为了函数表达式，并且这个函数表达式通过加上后边的一对小括号可以立即执行；例如

	（function (){var a = 2;console.log(a)}）();

这种模式有个术语，叫做IIFE，代表的是立即执行函数表达式（Immediately Involed Functiong Expression）；

IIFE的一种普遍的进阶的方式是把他们当作函数调用，别且传递参数进去
	var a = 2;
	(function IIFE( global ) {
	v	ar a = 3;
		console.log( a ); // 3
		console.log( global.a ); // 2
	})( window );
	console.log( a ); // 2

我们将window对象当作实参引入，但是给形参命名为window，这样使得全局变量的引用变得更加清晰；
这种方式并不局限于全局变量，实际上你可以将任何你想要传递东西从外部作用域传递进去，并将变量名命为你所熟悉的名字，这有助你改进你的代码风格；

这种方式可以用于判断undefined标识符有没有定义其他的值，虽然这种并不常见；

	(function IIFE( undefined ) {
		var a;
		if (a === undefined) {
		console.log( "Undefined is safe here!" );
		}
	})();
这是在函数表达式内部定义了一个变量a，但是并不赋值，确保a的值任何情况下都为undefined；然后通过传参对undefined值做比较；

##3.4 块作用域##

尽管函数作用域是最常见的作用域单元，但是其他类型的作用域也是存在的，熟练使用这些作用域将会使得你的代码更加的简介，优秀以及便于维护；

	for（var i=0;i<10;i++）{
		console.log(i);
	}

通常我们在for循环头部定义了变量i，是想要只在for循环内部使用i，而忽略i会被绑定在外部作用域的本质；

	var foo = true;
	if (foo) {
	var bar = foo * 2;
	bar = something( bar );
	console.log( bar );
	}

虽然bar变量在if判断语句内部定义，但是使用var定义的标识符，不管写在哪里都是一样的，因为他们最终都会绑定在外部作用域；

现在看来，JS并没有块作用域的机制，除非你深入研究JS的作用域机制；

###with###

利用with关键字所创建的作用域只在with所在的作用域生效而非外部的作用域；

###try/catch###

ES3中规定try/catch中的catch分句也会创建一个块作用域，catch中声明的变量只能用于catch内部，在外部调用则会报错；

###let###

可能到此为止，JS的块级作用域总会掺杂着一些奇怪的功能，但是如果仅仅是这样，那么块级作用域也不会成为我们的一个非常有用的机制了；

ES6中引入了一个新的关键字叫做let，let给我们提供了除了var以外的另一种声明变量的方式；

使用let声明的变量将会绑定到块级作用域当中**这和var不同，用var声明的变量只能绑定到全局和函数作用域之内；**，

例如：

	for（let i = 0；i < 10; i++）{
		console.log(i);
	}

	console.log(i) //error；

let还有一个非常不错的机制就是在于for循环是，每个单次循环内绑定的i都是一个新的变量，这点非常有用。留待闭包之后说明；

当然，这也牵扯到了一个问题，若每次循环时都绑定了一个新的i，那么为什么会输出的是0,1,2,3,4,5。。。而不是全是0呢；

这是因为JS引擎会记住本次循环后的值，当下次循环初始化变量i的时候，是在上一轮值得基础上计算的；

**另外，针对于块级作用域中得for作用域有个特别之处在于，设置循环变量的那部分是一个父级作用域，而循环体内部是一个单独的子作用域；**

###const###

ES6中还为我们规定了另一个创建块级作用域变量的声明方式叫做const；

	for（let i = 0；i < 10; i++）{
		const b = 1;
		console.log(i);
	}

	console.log(b) //error；

但是要注意一点const创建的块级作用域标识符是唯一的（类似ID），并且是属于常量，任何更改都会报错

	const b = 1；
	b = 4 //error；


##3.5 提升##

JS的编译器在读取代码时，会有一个预编译的过程；例如

	console.log(x);
	var x = 2;

此处代码会输出undefined，这就是因为编译器会预先将变量和函数的声明在运行前提前处理；

**注意一个细节，函数的声明要比变量的声明还要提前**

**另外，使用let声明的变量并不会被提升，这点要切记**